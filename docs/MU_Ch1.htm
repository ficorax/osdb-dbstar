<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset="windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>db.* Multi-User Guide Chapter 1</TITLE>
</HEAD>
<BODY>

<H1 ><A name="Introduction"></A>Chapter 1<BR>
Introduction</H1>
<H2><A name="Overview"></A>1.1 Overview</H2>
<FONT SIZE="2"><P>Welcome to the <B><I>db.*</B></I> system.</P>
<P>This manual contains the information you need to build your application in multi-user mode.  It explains how to get the lock manager utility up and running, plus how to use <B><I>db.*</B></I> on a variety of platforms.  The <B><I>db*</B> User's Guide</I> also contains information on multi-user operation.  Refer to Chapter 7, "Multi-User Database Control," of the <I>User's Guide</I> for information on file locking, timestamping, concurrency, and considerations on program design.  Be sure to consult the <B>readme.txt</B> file included in your product package for up-to-the-minute changes and information not included in the manuals.  </P>
<P>This<I> Multi-User Guide </I>is organized as follows:</P>
<P>Chapter 1, "Introduction," describes the theory of operation of a lock manager, and why a lock manager is necessary for all multi-user, shared database applications.</P>
<P>Chapter 2, "Lock Manager Operation," describes how to use the lock manager and how to configure the runtime library for multi-user operation.</P>
<P>Chapter 3, "Platform Dependencies," provides information concerning the use of <B><I>db.*</B></I> with a variety of different operating systems and network protocols.</P>
<P>Chapter 4, "Lock Manager Reference," provides the reference material for the lock manager, including descriptions of related utilities and function calls.</P>
</FONT><H2><A name="Theory"></A>1.2 Lock Manager Theory</H2>
<FONT SIZE="2"><P>The most important feature of a multi-user database is protecting data integrity when many applications are reading from and writing to the same set of files.  In this chapter we will examine the components that provide safe multi-user access, how the components communicate, and how the components can dependably work with your data.</P>
</FONT><H3><A name="Components"></A>1.2.1<I>db.*</I> Multi-User Components</H3>
<FONT SIZE="2"><P>With<B><I> db.*</B></I>, a lock manager is used to manage file locks and automatically recover failed transactions.  The lock manager itself never reads or writes database, LOG, or TAF files.  Normally the lock manager is a separate program that runs on a single machine on your network.</P>
<P>Applications based on <B><I>db.*</B></I> communicate with the lock manager to request permission to access a database file.  The code for this communication is built into the <B><I>db.*</B></I> runtime library, and uses the facilities of the hosting environment.</P>
<P>The database, which the applications access, can be hosted anywhere that provides file system access to the application.  This is not necessarily on the same machine as any application or the lock manager.  </P>
<P>The applications will also create files (TAF, LOG, and DBL) that are by-products of the locking process.</P>
</FONT><H3><A name="Communication"></A>1.2.2 Establishing Communication</H3>
<FONT SIZE="2"><P>First, the <B><I>db.*</B></I> lock manager must be started so that applications can use it.</P>
<P>The applications connect to the lock manager to open their databases.  When the <B>d_open</B> function successfully returns, the runtime will have already created a persistent connection to the running lock manager that will be maintained until all the user's databases have been closed.  Associated with each connection is a user identifier of not more than 15 characters, set through <B>d_dbuserid</B> or through the environment variable DBUSERID.  One connection and one unique userid exist per DB_TASK.</P>
<P>Applications use this connection to submit requests to the lock manager.  Requests can include file locks and unlocks, transaction commits, status requests, and the terminal close that will end the connection.  The lock manager never initiates contact with an application; all packets from the lock manager are responses to application requests.</P>
<P>Network problems, crashed applications, or an unexpectedly terminated lock manager can abruptly interrupt this orderly exchange of data.  If the lock manager loses contact with an application, it will clear out the user's data and prepare for recovery if necessary.  If an application loses contact with the lock manager, it will receive an error code of S_LMCERROR in response to a call to the runtime library.</P>
</FONT><H3><A name="Using"></A>1.2.3 Using The Database</H3>
<FONT SIZE="2"><P>Most requests are lock requests, where the application asks for read or write locks on files in the opened databases.  No locks are active on a just-opened database.</P>
<P>The life cycle of a lock begins with the application sending a lock request.  If it cannot be granted immediately, the request is queued with all other lock requests.  The oldest pending request that can be granted is always granted first.  The lock manager rejects a lock request only if it cannot be granted before the user's specified timeout elapses.</P>
<P>All locks are file locks.  Any number of users can have concurrent read locks.  If any read locks are outstanding, write locks on the same file will be queued to be granted as soon as possible.  A write lock prevents any other lock from being granted on the same file.</P>
</FONT><H3><A name="Transactions"></A>1.2.4 Transactions</H3>
<FONT SIZE="2"><P>The lock manager is not involved in a transaction until the application calls <B>d_trend</B>.  After writing all database changes to the LOG file and before writing to the database files, the runtime sends a "transaction commit begin" message (which includes the LOG filename) to the lock manager.  The lock manager flags the user as "in the process of committing a transaction" and then stores the LOG filename.</P>
<P>When the runtime receives the lock manager's reply, it is free to begin writing to the database.  The changes are migrated from the LOG file to the database files.  When all writing is complete, the runtime sends a "transaction commit end" message to the lock manager.  The lock manager unflags the user.  This completes the life cycle of a successful transaction.</P>
<P>If communication is disrupted before the "transaction commit end" message is received, the lock manager will know that a transaction was in progress and prepare for auto-recovery.  For preparation, the lock manager tells the next application sending any database open or lock request packet to perform a recovery based on the LOG file written by the lost application.  The automatic recovery process is described in section 6.5, "Database Recovery," of the <B><I>db.*</B></I> <I>User's Guide</I>.</P>
</FONT><H3><A name="SystemFiles"></A>1.2.5<I>db.*</I> System Files</H3>
<FONT SIZE="2"><P>The LOG file contains all the data written to a database in a single transaction, and provides data integrity in the case of an application crash during writes to the database files.  The LOG file is written by the runtime, and must be stored in a location visible to all applications using the same lock manager.  All LOG files must be stored in the same directory.  The LOG directory is specified using <B>d_dblog</B>, <B>db.star.ini</B>, or the environment variable DBLOG.  One LOG file exists per user (per DB_TASK) and cannot be shared.  The name of the LOG file (without extension or path) is the userid truncated to 8 characters.</P>
<P>The TAF file has two purposes:  1) it ensures that all users of a database use the same lock manager, and  2) it provides pointers to LOG files for outstanding transactions in the event of a simultaneous lock manager and application crash.  Each database has only one TAF file, but a single TAF file may serve more than one database.</P>
<P>All users of a database must use the same TAF path, which is specified using <B>d_dbtaf</B>, <B>db.star.ini</B>, or the environment variable DBTAF.  If the TAF file does not exist, the <B><I>db.*</B></I> runtime creates it when you call <B>d_open</B>, writing to the TAF file the lock manager name (as set through <B>d_lockmgr</B>, etc.) and type (for example, LMC_TCP).  If the current lock manager name and type do not match those in an existing TAF file, <B>d_open</B> will fail and return S_TAFSYNC.  Deleting the TAF file eliminates this error.  However, if the database is corrupt and needs recovery, deleting the TAF file will prevent the recovery from occurring and you will be left with a corrupted database.</P>
<P>Unless the MULTITAF option is enabled, <B><I>db.*</B></I> will only create one TAF file, which will be shared by all users.  <B><I>db.*</B></I> uses operating system specific functions to lock the TAF file, to prevent multiple users from writing to it simultaneously.  However, on some networked systems these locking functions may be slow.  <B><I>db.*</B></I> therefore provides the MULTITAF option, which causes a TAF file to be created for each user, avoiding the need for locking.  The TAF files must all be located same directory, otherwise <B><I>db.*</B></I> s auto-recovery mechanism will not work correctly, in the event of system failure during a transaction.  The directory is specified through <B>d_dbtaf</B>, <B>db.star.ini</B>, or the environment variable DBTAF; trailing characters after the last directory character will be ignored.</P>
<P>The DBL file is created by the General lock manager.  This lock manager involves cooperation between runtimes only, and uses no lock manager process.  All information about files, locks, and users is stored in the DBL file instead of in the memory of a lock manager program.  Each database has only one DBL file, but a single DBL file may serve more than one database.</P>
</FONT></BODY>
</HTML>
